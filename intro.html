import React, { useState, useEffect, useRef } from 'react';

export default function WKTWViz() {
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [glitchActive, setGlitchActive] = useState(false);
  const [blackHole, setBlackHole] = useState(false);
  const canvasRef = useRef(null);
  const audioContextRef = useRef(null);
  const starsRef = useRef([]);

  useEffect(() => {
    const handleMouseMove = (e) => {
      setMousePos({ x: e.clientX, y: e.clientY });
    };
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);

  useEffect(() => {
    const interval = setInterval(() => {
      setGlitchActive(true);
      setTimeout(() => setGlitchActive(false), 150);
    }, 3000 + Math.random() * 2000);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    // Start audio immediately
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioContext();
    audioContextRef.current = ctx;

    // More complex 808 bass
    const create808 = (freq, time, duration = 0.5, slide = false) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const filter = ctx.createBiquadFilter();
      
      filter.type = 'lowpass';
      filter.frequency.value = 180;
      filter.Q.value = 2;
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, time);
      if (slide) {
        osc.frequency.exponentialRampToValueAtTime(freq * 0.7, time + 0.1);
      }
      osc.frequency.exponentialRampToValueAtTime(freq * 0.01, time + duration);
      
      gain.gain.setValueAtTime(0.9, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(ctx.destination);
      
      osc.start(time);
      osc.stop(time + duration);
    };

    // Synth lead (Uzi-style)
    const createSynth = (freq, time, duration = 0.3) => {
      const osc = ctx.createOscillator();
      const osc2 = ctx.createOscillator();
      const gain = ctx.createGain();
      const filter = ctx.createBiquadFilter();
      
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1200, time);
      filter.frequency.exponentialRampToValueAtTime(400, time + duration);
      filter.Q.value = 4;
      
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      osc2.type = 'square';
      osc2.frequency.value = freq * 1.01; // Slight detune
      
      gain.gain.setValueAtTime(0.15, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
      
      osc.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(ctx.destination);
      
      osc.start(time);
      osc2.start(time);
      osc.stop(time + duration);
      osc2.stop(time + duration);
    };

    // Uzi-style pluck synth
    const createPluck = (freq, time) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const filter = ctx.createBiquadFilter();
      
      filter.type = 'lowpass';
      filter.frequency.value = 2000;
      
      osc.type = 'triangle';
      osc.frequency.value = freq;
      
      gain.gain.setValueAtTime(0.25, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(ctx.destination);
      
      osc.start(time);
      osc.stop(time + 0.4);
    };

    // Hi-hat with variation
    const createHiHat = (time, open = false) => {
      const noise = ctx.createBufferSource();
      const duration = open ? 0.15 : 0.05;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * duration, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      noise.buffer = buffer;
      
      const filter = ctx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 8000;
      
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(open ? 0.12 : 0.18, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(ctx.destination);
      
      noise.start(time);
    };

    // Snare
    const createSnare = (time) => {
      const noise = ctx.createBufferSource();
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.12, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      noise.buffer = buffer;
      
      const filter = ctx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 1500;
      
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.35, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.12);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(ctx.destination);
      
      noise.start(time);
    };

    // Beat pattern with variation
    const playBeat = (variation = 0) => {
      const now = ctx.currentTime;
      const bpm = 145;
      const beatDuration = 60 / bpm;
      
      // Bass patterns with variations
      if (variation % 2 === 0) {
        create808(55, now, 0.4); // F
        create808(55, now + beatDuration * 1, 0.3);
        create808(65, now + beatDuration * 2, 0.4); // C
        create808(73, now + beatDuration * 3, 0.35, true); // D with slide
        create808(49, now + beatDuration * 3.5, 0.3); // G#
      } else {
        create808(55, now, 0.4);
        create808(46, now + beatDuration * 1.5, 0.3); // A#
        create808(65, now + beatDuration * 2.5, 0.4);
        create808(55, now + beatDuration * 3.5, 0.3);
      }
      
      // Uzi-style melody patterns (first 4 notes only)
      if (variation % 4 === 0 || variation % 4 === 2) {
        // Melodic lead - clean 4 note pattern
        createSynth(880, now + beatDuration * 0.5, 0.3);
        createSynth(1047, now + beatDuration * 1, 0.25);
        createSynth(988, now + beatDuration * 1.75, 0.2);
        createSynth(1175, now + beatDuration * 2.5, 0.3);
      }
      
      // Hi-hats with rolls and open hats
      for (let i = 0; i < 16; i++) {
        const isOpen = i === 7 || i === 15;
        createHiHat(now + (beatDuration / 4) * i, isOpen);
      }
      
      // Snare pattern
      createSnare(now + beatDuration * 2);
      createSnare(now + beatDuration * 6);
      if (variation % 4 === 3) {
        createSnare(now + beatDuration * 3.75); // Extra snare roll
      }
    };

    // Loop with variation counter
    let beatCount = 0;
    const loopBeat = () => {
      playBeat(beatCount);
      beatCount++;
      setTimeout(loopBeat, (60 / 145) * 8 * 1000);
    };
    
    // Start after brief delay for audio context
    setTimeout(() => {
      ctx.resume().then(() => loopBeat());
    }, 100);

    return () => {
      if (ctx.state !== 'closed') {
        ctx.close();
      }
    };
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Initialize stars
    if (starsRef.current.length === 0) {
      for (let i = 0; i < 150; i++) {
        starsRef.current.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 0.5,
          opacity: Math.random(),
          fadeSpeed: Math.random() * 0.02 + 0.01,
          fadeDirection: Math.random() > 0.5 ? 1 : -1
        });
      }
    }

    // Asteroids
    const asteroids = [];
    for (let i = 0; i < 30; i++) {
      asteroids.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 1.5,
        vy: (Math.random() - 0.5) * 1.5,
        size: Math.random() * 3 + 2,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.05
      });
    }

    // Interactive planets with initial positions
    const planets = [
      { x: canvas.width * 0.15, y: canvas.height * 0.2, originX: canvas.width * 0.15, originY: canvas.height * 0.2, radius: 40, color: '#dc2626', rings: false, speed: 0.3 },
      { x: canvas.width * 0.85, y: canvas.height * 0.3, originX: canvas.width * 0.85, originY: canvas.height * 0.3, radius: 55, color: '#f59e0b', rings: true, speed: 0.4 },
      { x: canvas.width * 0.1, y: canvas.height * 0.7, originX: canvas.width * 0.1, originY: canvas.height * 0.7, radius: 35, color: '#8b5cf6', rings: false, speed: 0.25 },
      { x: canvas.width * 0.9, y: canvas.height * 0.75, originX: canvas.width * 0.9, originY: canvas.height * 0.75, radius: 45, color: '#06b6d4', rings: false, speed: 0.35 },
    ];

    let animationId;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const animate = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw stars
      starsRef.current.forEach(star => {
        star.opacity += star.fadeSpeed * star.fadeDirection;
        if (star.opacity > 1) {
          star.opacity = 1;
          star.fadeDirection = -1;
        } else if (star.opacity < 0) {
          star.opacity = 0;
          star.fadeDirection = 1;
        }

        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
        ctx.save();
        ctx.translate(star.x, star.y);
        ctx.rotate(Math.PI / 4);
        
        // Draw 4-pointed star
        ctx.beginPath();
        for (let i = 0; i < 4; i++) {
          const angle = (i * Math.PI) / 2;
          const x1 = Math.cos(angle) * star.size;
          const y1 = Math.sin(angle) * star.size;
          const x2 = Math.cos(angle + Math.PI / 4) * (star.size * 0.3);
          const y2 = Math.sin(angle + Math.PI / 4) * (star.size * 0.3);
          
          if (i === 0) ctx.moveTo(x1, y1);
          else ctx.lineTo(x1, y1);
          ctx.lineTo(x2, y2);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      });

      // Draw interactive planets
      planets.forEach(planet => {
        // Ensure planet positions are valid numbers
        if (!isFinite(planet.x)) planet.x = planet.originX;
        if (!isFinite(planet.y)) planet.y = planet.originY;
        
        const dx = mousePos.x - planet.x;
        const dy = mousePos.y - planet.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // React to mouse
        if (dist < 150 && dist > 0) {
          const pushX = -(dx / dist) * (150 - dist) * 0.02;
          const pushY = -(dy / dist) * (150 - dist) * 0.02;
          planet.x += pushX;
          planet.y += pushY;
        }
        
        // Slow drift back to original position
        planet.x += (planet.originX - planet.x) * 0.01;
        planet.y += (planet.originY - planet.y) * 0.01;

        if (blackHole) {
          const dxCenter = centerX - planet.x;
          const dyCenter = centerY - planet.y;
          const distCenter = Math.sqrt(dxCenter * dxCenter + dyCenter * dyCenter);
          if (distCenter > 0) {
            const force = Math.min(60 / (distCenter + 1), 6);
            planet.x += (dxCenter / distCenter) * force * planet.speed;
            planet.y += (dyCenter / distCenter) * force * planet.speed;
          }
        }

        const distToCenter = Math.sqrt((centerX - planet.x) ** 2 + (centerY - planet.y) ** 2);
        const opacity = blackHole ? Math.max(0, 1 - distToCenter / 500) : 1;

        // Draw planet
        const gradient = ctx.createRadialGradient(
          planet.x - planet.radius * 0.3, 
          planet.y - planet.radius * 0.3, 
          0, 
          planet.x, 
          planet.y, 
          planet.radius
        );
        gradient.addColorStop(0, planet.color);
        gradient.addColorStop(1, '#000000');
        
        ctx.fillStyle = gradient;
        ctx.globalAlpha = opacity;
        ctx.beginPath();
        ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw rings if applicable
        if (planet.rings) {
          ctx.strokeStyle = `${planet.color}80`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.ellipse(planet.x, planet.y, planet.radius * 1.5, planet.radius * 0.3, 0, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Glow
        ctx.strokeStyle = `${planet.color}40`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(planet.x, planet.y, planet.radius + 3, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.globalAlpha = 1;
      });

      // Draw and update asteroids
      asteroids.forEach(a => {
        if (blackHole) {
          const dx = centerX - a.x;
          const dy = centerY - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const force = Math.min(80 / (dist + 1), 8);
          a.vx += (dx / dist) * force * 0.15;
          a.vy += (dy / dist) * force * 0.15;
        }

        a.x += a.vx;
        a.y += a.vy;
        a.rotation += a.rotationSpeed;

        if (!blackHole) {
          if (a.x < 0 || a.x > canvas.width) a.vx *= -1;
          if (a.y < 0 || a.y > canvas.height) a.vy *= -1;
        }

        const distToCenter = Math.sqrt((centerX - a.x) ** 2 + (centerY - a.y) ** 2);
        const opacity = blackHole ? Math.max(0, 1 - distToCenter / 500) : 1;

        ctx.save();
        ctx.translate(a.x, a.y);
        ctx.rotate(a.rotation);
        ctx.fillStyle = `rgba(150, 150, 150, ${opacity})`;
        
        // Draw irregular asteroid shape
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const radius = a.size * (0.7 + Math.random() * 0.3);
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      });

      // Draw Earth in center
      if (!blackHole) {
        const earthRadius = 315; // 1.5x bigger than previous (210 * 1.5)
        
        // Earth
        const earthGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, earthRadius);
        earthGradient.addColorStop(0, '#1e40af');
        earthGradient.addColorStop(0.5, '#1e3a8a');
        earthGradient.addColorStop(1, '#0f172a');
        
        ctx.fillStyle = earthGradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, earthRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Green continents (scaled up 1.5x more)
        ctx.fillStyle = '#166534';
        ctx.beginPath();
        ctx.arc(centerX - 157, centerY - 117, 117, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX + 117, centerY + 78, 141, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - 78, centerY + 157, 94, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX + 180, centerY - 90, 78, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - 202, centerY + 67, 63, 0, Math.PI * 2);
        ctx.fill();
        
        // Earth glow
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.arc(centerX, centerY, earthRadius + 12, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Black hole effect
      if (blackHole) {
        ctx.save();
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 400);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
        gradient.addColorStop(0.3, 'rgba(20, 20, 20, 0.8)');
        gradient.addColorStop(0.6, 'rgba(40, 40, 40, 0.4)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }

      animationId = requestAnimationFrame(animate);
    };

    animate();

    return () => cancelAnimationFrame(animationId);
  }, [mousePos, blackHole]);

  const handleEnter = () => {
    setBlackHole(true);
    setTimeout(() => {
      window.location.href = 'https://wktw-site.pages.dev/';
    }, 3000);
  };

  return (
    <div className="relative w-full h-screen bg-black overflow-hidden cursor-crosshair">
      <canvas ref={canvasRef} className="absolute inset-0" />

      {/* Main content */}
      <div className={`relative z-10 flex flex-col items-center justify-center h-full text-white transition-all duration-1000 ${
        blackHole ? 'opacity-0 scale-50' : 'opacity-100 scale-100'
      }`}>
        <div className="text-center space-y-12">
          {/* Title with glitch */}
          <div className="relative">
            <h1 
              className={`relative text-8xl md:text-9xl font-black tracking-tighter transition-all duration-75 ${
                glitchActive ? 'opacity-80' : 'opacity-100'
              }`}
              style={{
                textShadow: glitchActive 
                  ? '5px 0 #ffffff, -5px 0 #888888'
                  : '0 0 20px rgba(255, 255, 255, 0.5)',
                transform: glitchActive ? 'translate(3px, -2px)' : 'none',
                color: '#ffffff',
              }}
            >
              WKTW
            </h1>
            {glitchActive && (
              <h1 
                className="absolute top-0 left-0 w-full text-8xl md:text-9xl font-black tracking-tighter opacity-70"
                style={{
                  transform: 'translate(-3px, 2px)',
                  color: '#ffffff',
                  mixBlendMode: 'screen',
                }}
              >
                WKTW
              </h1>
            )}
          </div>

          {/* Subtitle */}
          <div className="space-y-2">
            <p className="text-xl md:text-2xl tracking-widest text-gray-400 font-light">
              WHO KILLED THE WORLD
            </p>
            <div className="flex items-center justify-center gap-2 text-gray-500">
              <div className="w-2 h-2 bg-white rounded-full animate-pulse" />
              <p className="text-sm tracking-wider">ALBUQUERQUE, NM</p>
            </div>
          </div>

          {/* Enter button */}
          <button
            onClick={handleEnter}
            className="group relative mt-16 px-12 py-4 bg-transparent border-2 border-white text-white text-lg tracking-widest font-bold overflow-hidden transition-all duration-300 hover:text-black"
            onMouseEnter={() => setGlitchActive(true)}
          >
            <span className="relative z-10">ENTER</span>
            <div className="absolute inset-0 bg-white transform translate-y-full group-hover:translate-y-0 transition-transform duration-300" />
          </button>

          {/* Flashing text */}
          <p className="text-xs tracking-widest text-white animate-pulse mt-8">
            SMALL BATCH • LIMITED RUN • NO RESTOCK
          </p>
        </div>
      </div>

      {/* Corner elements */}
      <div className={`absolute top-8 left-8 text-white text-xs tracking-widest font-mono transition-opacity duration-1000 ${
        blackHole ? 'opacity-0' : 'opacity-100'
      }`}>
        001
      </div>
      <div className={`absolute top-8 right-8 text-white text-xs tracking-widest font-mono transition-opacity duration-1000 ${
        blackHole ? 'opacity-0' : 'opacity-100'
      }`}>
        DROP_001
      </div>
      <div className={`absolute bottom-8 left-8 text-gray-500 text-xs tracking-widest transition-opacity duration-1000 ${
        blackHole ? 'opacity-0' : 'opacity-100'
      }`}>
        © WKTW LTD. CO.
      </div>
      <div className={`absolute bottom-8 right-8 text-white text-xs tracking-widest animate-pulse transition-opacity duration-1000 ${
        blackHole ? 'opacity-0' : 'opacity-100'
      }`}>
        ● LIVE
      </div>
    </div>
  );
}
